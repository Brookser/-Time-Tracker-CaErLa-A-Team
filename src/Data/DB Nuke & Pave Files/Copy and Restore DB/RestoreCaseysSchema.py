# **********************************************************************************************************************
# **********************************************************************************************************************   
# Author:           Erika Brooks
# TTfeature:        Test_01
# Date:             04.24.2025
# Description:      Restores Casey's Data tables and schema
# Input:            none
# Output:           confirmation message
# Sources:          Project Charter - Jira Story: Tests 1 & 2
#
# Change Log:       - 04.24.2025: Initial setup
#                   - time_tracker_schema_backup file was updated due to adding table employee_projects
#                           updated filename in this script to align with updated schema
#                   - 05.01.2025: changes made directly to DB via console script
#                       by server manager; time_tracker_schema_backup_20250501_180100.sql
#                       is now the current file
#                   - 05.05.2025: changes made directly to DB via console script
#                       by server manager; time_tracker_schema_backup_20250505_123458.sql
#                       is now the current file
#
# **********************************************************************************************************************
# **********************************************************************************************************************  
#!/usr/bin/env python3
"""
MariaDB Schema Restore Script

This script restores a MariaDB database from a schema backup file
generated by the schema backup script.
"""

import os
import sys
import re
import argparse
import mariadb
import time
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()


def connect_to_server():
    """
    Connect to MariaDB server without specifying a database
    """
    # Check if required environment variables are set
    required_vars = ["DB_USER", "DB_PASSWORD", "DB_HOST"]
    missing_vars = [var for var in required_vars if not os.getenv(var)]

    if missing_vars:
        print(f"Error: The following required environment variables are not set: {', '.join(missing_vars)}")
        print("Please set these environment variables in your .env file before running the script.")
        sys.exit(1)

    # Handle DB_PORT with default value if not set
    db_port = os.getenv("DB_PORT")
    if db_port is None:
        db_port = 3306  # Default MariaDB port
        print(f"Warning: DB_PORT not set, using default port {db_port}")
    else:
        try:
            db_port = int(db_port)
        except ValueError:
            print(f"Error: DB_PORT value '{db_port}' is not a valid integer")
            sys.exit(1)

    try:
        # Connect to MariaDB without specifying a database
        conn = mariadb.connect(
            user=os.getenv("DB_USER"),
            password=os.getenv("DB_PASSWORD"),
            host=os.getenv("DB_HOST"),
            port=db_port,
            connect_timeout=5
        )
        print(f"Successfully connected to MariaDB server at {os.getenv('DB_HOST')}:{db_port}")
        return conn
    except mariadb.Error as e:
        print(f"Error connecting to MariaDB server: {e}")
        sys.exit(1)


def extract_database_name(sql_file_path):
    """
    Extract the database name from the backup file
    """
    db_name = None

    try:
        with open(sql_file_path, 'r') as f:
            for line in f:
                # Extract database name from CREATE DATABASE statement
                db_name_match = re.search(r'CREATE DATABASE.*?`([^`]+)`', line)
                if db_name_match:
                    db_name = db_name_match.group(1)
                    break

                # Extract from header comment
                header_match = re.search(r'-- MariaDB Schema Backup for database: (\w+)', line)
                if header_match:
                    db_name = header_match.group(1)
                    break

        # If no database name found, use from environment variables
        if not db_name:
            db_name = os.getenv("DB_NAME")
            if not db_name:
                print("Error: Could not determine database name from backup file or environment variables")
                sys.exit(1)

        return db_name

    except IOError as e:
        print(f"Error reading backup file: {e}")
        sys.exit(1)


def execute_sql_file(conn, cursor, sql_file_path, db_name):
    """
    Execute SQL commands from the backup file
    Handles multi-statement queries and DELIMITER changes
    """
    print("Starting database restoration process...")

    try:
        with open(sql_file_path, 'r') as f:
            content = f.read()

        # Split the file into SQL statements
        current_delimiter = ';'
        statements = []
        current_statement = ''
        in_delimiter_mode = False

        for line in content.splitlines():
            # Skip comments and empty lines
            if line.strip().startswith('--') or not line.strip():
                continue

            # Skip database creation/drop statements
            if re.match(r'(CREATE|DROP)\s+DATABASE', line, re.IGNORECASE) or re.match(r'USE\s+', line, re.IGNORECASE):
                continue

            # Handle DELIMITER changes
            delimiter_match = re.match(r'DELIMITER\s+(\S+)', line)
            if delimiter_match:
                if current_statement.strip():
                    statements.append(current_statement.strip())
                    current_statement = ''

                current_delimiter = delimiter_match.group(1)
                in_delimiter_mode = True if current_delimiter != ';' else False
                continue

            # Add line to current statement
            current_statement += line + '\n'

            # Check if statement is complete
            if line.strip().endswith(current_delimiter):
                # Remove delimiter from the end
                current_statement = current_statement.rstrip('\n')
                if in_delimiter_mode:
                    current_statement = current_statement[:-len(current_delimiter)]
                else:
                    current_statement = current_statement[:-1]  # Remove semicolon

                if current_statement.strip():
                    statements.append(current_statement.strip())
                current_statement = ''

        # Add any remaining statement
        if current_statement.strip():
            statements.append(current_statement.strip())

        # Execute statements
        total_statements = len(statements)
        print(f"Found {total_statements} SQL statements to execute")

        # Make sure we're using the right database
        cursor.execute(f"USE `{db_name}`")

        # Disable foreign key checks temporarily
        cursor.execute("SET FOREIGN_KEY_CHECKS = 0")

        for i, statement in enumerate(statements, 1):
            try:
                # Print progress
                if i % 10 == 0 or i == 1 or i == total_statements:
                    print(f"Executing statement {i}/{total_statements} ({int(i / total_statements * 100)}%)")

                cursor.execute(statement)
                conn.commit()
            except mariadb.Error as e:
                print(f"Error executing statement {i}: {e}")
                print(f"Statement: {statement[:150]}..." if len(statement) > 150 else f"Statement: {statement}")
                print("Continuing with next statement...")
                # Continue execution despite errors
                conn.rollback()

        # Re-enable foreign key checks
        cursor.execute("SET FOREIGN_KEY_CHECKS = 1")

        print("Database restoration completed successfully!")

    except IOError as e:
        print(f"Error reading backup file: {e}")
        sys.exit(1)


def verify_restoration(cursor, db_name):
    """
    Verify that database objects were created successfully
    """
    print("\nVerifying database restoration...")

    try:
        # Check tables
        cursor.execute("SHOW TABLES")
        tables = cursor.fetchall()
        print(f"Verified {len(tables)} tables were created")
        if tables:
            print("Tables created:")
            for i, table in enumerate(tables):
                print(f"  {i + 1}. {table[0]}")

        # Check routines
        cursor.execute("""
            SELECT routine_type, COUNT(*) 
            FROM information_schema.routines 
            WHERE routine_schema = %s 
            GROUP BY routine_type
        """, (db_name,))
        routines = cursor.fetchall()
        for routine_type, count in routines:
            print(f"Verified {count} {routine_type.lower()}s were created")

        # Check triggers
        cursor.execute("""
            SELECT COUNT(*) 
            FROM information_schema.triggers 
            WHERE trigger_schema = %s
        """, (db_name,))
        trigger_count = cursor.fetchone()[0]
        if trigger_count > 0:
            print(f"Verified {trigger_count} triggers were created")

        # Check views
        cursor.execute("""
            SELECT COUNT(*) 
            FROM information_schema.views 
            WHERE table_schema = %s
        """, (db_name,))
        view_count = cursor.fetchone()[0]
        if view_count > 0:
            print(f"Verified {view_count} views were created")

    except mariadb.Error as e:
        print(f"Error verifying restored database: {e}")


def restore_database_schema(backup_file_path):
    """
    Main function to restore a database from a schema backup file
    """
    if not os.path.exists(backup_file_path):
        print(f"Error: Backup file {backup_file_path} does not exist")
        sys.exit(1)

    print(f"Using backup file: {backup_file_path}")

    # Extract database name
    db_name = extract_database_name(backup_file_path)
    print(f"Target database name: {db_name}")

    # Connect to MariaDB server (without database)
    conn = connect_to_server()
    cursor = conn.cursor()

    try:
        # Check if database exists
        cursor.execute("SHOW DATABASES")
        databases = [db[0] for db in cursor.fetchall()]

        if db_name in databases:
            print(f"Database '{db_name}' already exists")
            response = input("Do you want to drop and recreate it? (yes/no): ").lower()
            if response == 'yes':
                print(f"Dropping database '{db_name}'...")
                cursor.execute(f"DROP DATABASE `{db_name}`")
                print(f"Creating database '{db_name}'...")
                cursor.execute(f"CREATE DATABASE `{db_name}`")
        else:
            # Create database if it doesn't exist
            print(f"Creating database '{db_name}'...")
            cursor.execute(f"CREATE DATABASE `{db_name}`")

        # Execute the SQL file
        print(f"Restoring schema to database: {db_name}")
        start_time = time.time()

        execute_sql_file(conn, cursor, backup_file_path, db_name)

        # Verify restoration
        verify_restoration(cursor, db_name)

        end_time = time.time()
        duration = end_time - start_time
        print(f"Restoration completed in {duration:.2f} seconds")

    except Exception as e:
        print(f"Error during database restoration: {e}")
        sys.exit(1)
    finally:
        cursor.close()
        conn.close()

    print(f"Database '{db_name}' has been successfully restored!")
    return db_name


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Restore a MariaDB database from a schema backup file')
    parser.add_argument('backup_file', nargs='?',
                        default='time_tracker_schema_backup_20250505_123458.sql',
                        help='Path to the schema backup SQL file (default: time_tracker_schema_backup_20250505_123458.sql)')
    args = parser.parse_args()

    print("=== MariaDB Schema Restore Tool ===")
    db_name = restore_database_schema(args.backup_file)
    print(f"=== Restore complete! Database '{db_name}' is ready to use ===")

# **********************************************************************************************************************
# **********************************************************************************************************************
